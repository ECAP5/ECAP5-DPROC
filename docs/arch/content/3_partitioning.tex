\section{Functional Partitioning}

\begin{content}
  ECAP5-DPROC is built around a pipelined architecture with the following stages :
  \begin{itemize}
    \vspace{-0.5em}
    \item The instruction fetch stage loads the next instruction from memory.
    \vspace{-0.5em}
    \item The decode stage handles the instruction decoding to provide the next stage with the different instruction input values including reading from internal registers.
    \vspace{-0.5em}
    \item The execute stage implements instruction behaviors. This includes performing integer operations as well as accessing memory.
    \vspace{-0.5em}
    \item The write-back stage which handles storing instructions outputs to internal registers.
  \end{itemize}

\begin{figure}[h!]
    \centering
    \input{docs/arch/figures/architecture.tex}
    \caption{Schematic view of the architecture of ECAP5-DPROC}
    \label{fig:architecture}
\end{figure}

  The design is split into the following functional modules :
  \begin{itemize}
    \vspace{-0.5em}
    \item The \textbf{Top Module} (TOPM) which integrates all other modules.
    \item The \textbf{External Memory Module} (EMM), in charge of accessing memory and peripherals.
    \vspace{-0.5em}
    \item The \textbf{Instruction Fetch Module} (IFM), in charge of implementing the instruction fetch stage.
    \vspace{-0.5em}
    \item The \textbf{Decode Module} (DECM), in charge of implementing the decode stage.
    \vspace{-0.5em}
    \item The \textbf{Register Module} (REGM), implementing the internal registers.
    \vspace{-0.5em}
    \item The \textbf{Execute Module} (EXM), in charge of implementing the execute stage.
    \item The \textbf{Write-Back Module} (WBM), in charge of implementing the write-back stage.
  \end{itemize}
\end{content}

\newpage

\section{Top Module}

\begin{content}
  Handshaking and bubbling
\end{content}

\newpage

\section{External Memory Module}
\newpage

\section{Instruction Fetch Module}
\begin{figure}[h!]
    \centering
    \input{docs/arch/figures/ifm.tex}
    \caption{Schematic view of the Instruction Fetch Module}
    \label{fig:regm}
\end{figure}

\begin{content}
The instruction fetch module handles fetching from memory the instructions to be executing. The signals are described in table \ref{tab:ifm-interface}. 
\end{content}

\input{docs/arch/tables/ifm.tex}

\begin{content}
  \texttt{pc} stores the value of the next instruction to be loaded from memory. It is connected to the wishbone master which performs the memory read. The read data is transfered to the output logic, in charge of handling the pipeline's handshaking protocol. The value of \texttt{pc} can be either incremented by the output logic, reset by \texttt{rst\_i} or loaded with a specific value through the jump logic.
\end{content}

\subsection{Jump logic}

\subsection{Wishbone master}

\subsection{Output logic}

\newpage
\section{Decode Module}
\newpage

\section{Register Module}

\begin{figure}[h!]
    \centering
    \input{docs/arch/figures/regm.tex}
    \caption{Schematic view of the Register Module}
    \label{fig:regm}
\end{figure}

\begin{content}
The register module implements the 32 internal registers of ECAP5-DPROC. It has two reading port and one writing port. The signals are described in table \ref{tab:regm-interface}. 
\end{content}

\begin{table}[H]
  \centering
  \input{docs/arch/tables/regm.tex}
  \caption{Register Module interface signals}
  \label{tab:regm-interface}
\end{table}

\begin{content}
  When reading, \texttt{rdata1\_i} and \texttt{rdata2\_i} output, on the rising edge of \texttt{clk\_i}, the value of the register respectively selected by \texttt{raddr1\_i} and \texttt{raddr2\_i}. A register write happens on the rising edge of \texttt{clk\_i} when \texttt{write\_i} is asserted, writing the value \texttt{wdata\_i} in the register selected by \texttt{waddr\_i}.
\end{content}

\newpage

\section{Execute Module}
\newpage

\section{Write-Back Module}
\newpage

\section{Debug}
\newpage

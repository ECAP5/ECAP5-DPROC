\section{Functional Partitioning}

\begin{content}
  ECAP5-DPROC is built around a pipelined architecture with the following stages :
  \begin{itemize}
    \vspace{-0.5em}
    \item The instruction fetch stage loads the next instruction from memory.
    \vspace{-0.5em}
    \item The decode stage handles the instruction decoding to provide the next stage with the different instruction input values including reading from internal registers.
    \vspace{-0.5em}
    \item The execute stage implements instruction behaviors. This includes performing integer operations as well as accessing memory.
    \vspace{-0.5em}
    \item The write-back stage which handles storing instructions outputs to internal registers.
  \end{itemize}

\begin{figure}[h!]
    \centering
    \input{docs/arch/figures/architecture.tex}
    \caption{Schematic view of the architecture of ECAP5-DPROC}
    \label{fig:architecture}
\end{figure}

  The design is split into the following functional modules :
  \begin{itemize}
    \vspace{-0.5em}
    \item The \textbf{Top Module} (TOPM) which integrates all other modules.
    \item The \textbf{External Memory Module} (EMM), in charge of accessing memory and peripherals.
    \vspace{-0.5em}
    \item The \textbf{Instruction Fetch Module} (IFM), in charge of implementing the instruction fetch stage.
    \vspace{-0.5em}
    \item The \textbf{Decode Module} (DECM), in charge of implementing the decode stage.
    \vspace{-0.5em}
    \item The \textbf{Register Module} (REGM), implementing the internal registers.
    \vspace{-0.5em}
    \item The \textbf{Execute Module} (EXM), in charge of implementing the execute stage.
    \item The \textbf{Write-Back Module} (WBM), in charge of implementing the write-back stage.
  \end{itemize}
\end{content}

\newpage

\section{Top Module}

\begin{content}
  Handshaking and bubbling
\end{content}

\newpage

\section{External Memory Module}
\newpage

\section{Instruction Fetch Module}

\begin{figure}[h!]
    \centering
    \input{docs/arch/figures/ifm.tex}
    \caption{Schematic view of the Instruction Fetch Module}
    \label{fig:regm}
\end{figure}

\subsection{Interface}

\begin{content}
The instruction fetch module handles fetching from memory the instructions to be executing. The signals are described in table \ref{tab:ifm-interface}. 
\end{content}

\input{docs/arch/tables/ifm.tex}

\subsection{Behavior}

\begin{content}
  \texttt{pc} stores the value of the next instruction to be loaded from memory. It is connected to the wishbone master which performs the memory read. The read data is transfered to the output logic, in charge of handling the pipeline's handshaking protocol. The value of \texttt{pc} can be either incremented by the output logic, reset by \texttt{rst\_i} or loaded with a specific value through the jump logic.

  This module doesn't contain any prefetch mechanism as there is no performance requirement for revision 1.0.0. This will lead to a performance bottleneck due to the number of cycles needed for fetching instructions from memory.
\end{content}

\subsection{Design}

\subsubsection{Jump logic}

\begin{figure}[H]
    \centering
    \input{docs/arch/figures/jump-logic.tex}
    \caption{Schematic view of the interface of the Jump Logic}
    \label{fig:jump-logic}
\end{figure}

\begin{content}
  The jump logic loads a value into the \texttt{pc} register based on inputs. Its interface is described in table \ref{tab:jump-logic}.
\end{content}

\input{docs/arch/tables/jump-logic.tex}

\begin{content}
\end{content}

\begin{content}
  Figures \ref{fig:jump-logic-behavior} and \ref{fig:jump-logic-output} describe the behavior of the jump logic. The values to be loaded in memory are hardcoded and set at compile time.
\end{content}

\begin{figure}[H]
    \centering
    \input{docs/arch/figures/jump-logic-behavior.tex}
    \caption{Activity diagram of the jump logic behavior}
    \label{fig:jump-logic-behavior}
\end{figure}

\begin{figure}[H]
    \centering
    \input{docs/arch/figures/jump-logic-output.tex}
    \caption{Timing diagram for the output port of the jump logic.}
    \label{fig:jump-logic-output}
\end{figure}

\subsubsection{PC register}

\begin{figure}[H]
    \centering
    \input{docs/arch/figures/pc-behavior.tex}
    \caption{Activity diagram of the pc register}
    \label{fig:pc-behavior}
\end{figure}

\subsubsection{Wishbone master}

\begin{figure}[H]
    \centering
    \input{docs/arch/figures/ifm-wishbone-master.tex}
    \caption{Schematic view of the interface of the Wishbone Master}
    \label{fig:ifm-wishbone-master}
\end{figure}

\begin{content}
  The wishbone master fetches from memory the instruction to be executed. Its interface is described in table \ref{tab:ifm-wishbone-master}.
  The memory port of the wishbone master is described in figure \ref{fig:ifm-wishbone-read}. 
\end{content}

\input{docs/arch/tables/ifm-wishbone-master.tex}

\begin{figure}[H]
  \centering
  \input{docs/arch/figures/ifm-wishbone-read.tex}
  \caption{Timing diagram for the memory port of IFM's wishbone master}
  \label{fig:ifm-wishbone-read}
\end{figure}

\begin{content}
  The output port of the wishbone master has the following properties:
  \begin{center}
    valid\_o = (wb\_stb\_o \& wb\_ack\_i)

    instr\_o[31:0] = wb\_dat\_i
  \end{center}
\end{content}

\subsubsection{Output logic}

\begin{figure}[H]
    \centering
    \input{docs/arch/figures/ifm-output-logic.tex}
    \caption{Schematic view of the interface of the Output Logic}
    \label{fig:ifm-output-logic}
\end{figure}

\newpage
\section{Decode Module}
\newpage

\section{Register Module}

\begin{figure}[h!]
    \centering
    \input{docs/arch/figures/regm.tex}
    \caption{Schematic view of the Register Module}
    \label{fig:regm}
\end{figure}

\subsection{Interface}

\begin{content}
The register module implements the 32 internal registers of ECAP5-DPROC. It has two reading port and one writing port. The signals are described in table \ref{tab:regm-interface}. 
\end{content}

\begin{table}[H]
  \centering
  \input{docs/arch/tables/regm.tex}
  \caption{Register Module interface signals}
  \label{tab:regm-interface}
\end{table}

\subsection{Behavior}

\begin{content}
  When reading, \texttt{rdata1\_i} and \texttt{rdata2\_i} output, on the rising edge of \texttt{clk\_i}, the value of the register respectively selected by \texttt{raddr1\_i} and \texttt{raddr2\_i}. A register write happens on the rising edge of \texttt{clk\_i} when \texttt{write\_i} is asserted, writing the value \texttt{wdata\_i} in the register selected by \texttt{waddr\_i}.
\end{content}

\subsection{Design}

\newpage

\section{Execute Module}
\newpage

\section{Write-Back Module}
\newpage

\section{Debug}
\newpage

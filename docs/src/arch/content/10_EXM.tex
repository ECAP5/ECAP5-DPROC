\section{Execute Module}

  \subsection{Interface}

    \begin{content}
        The execute module implements TBC. The signals are described in table \ref{tab:exm-interface}. 
      \end{content}

    \input{arch/tables/10_exm-interface}

  \subsection{Specification}

    \subsubsection{Input registering}

      \event{EV\_EXM\_INPUT\_REGISTER\_01}{
          This event represents a successfull input handshake.
        }

      \req{D\_EXM\_INPUT\_REGISTER\_01}{
          On the rising edge of \texttt{clk\_i} when both \texttt{input\_valid\_i} and \texttt{input\_ready\_o} are asserted, \eventref{EV\_EXM\_INPUT\_REGISTER\_01} shall be triggered.
        }

    \subsubsection{Load/Store}

    \subsubsection{Wishbone interface}

    \subsubsection{Output}

      \req{D\_EXM\_OUTPUT\_ADDR\_01}{
          The value of \texttt{result\_addr\_o} shall be set the to the value of \texttt{result\_addr\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}.
        }

      \req{D\_EXM\_OUTPUT\_WRITE\_01}{
          The \texttt{result\_write\_o} output shall be asserted on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is one of the following : \texttt{LUI}, \texttt{AUIPC}, \texttt{JAL}, \texttt{JALR}, \texttt{OP} and \texttt{OP-IMM}.
        }

      \req{D\_EXM\_OUTPUT\_WRITE\_02}{
          The value of \texttt{result\_write\_o} shall be deasserted on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is \texttt{BRANCH}.
        }

      \req{D\_EXM\_OUTPUT\_WRITE\_03}{
          The value of \texttt{result\_write\_o} shall be asserted on the rising edge of \texttt{clk\_i} following the completion of the memory request when \texttt{opcode\_i} is one of the following: \texttt{LOAD} and \texttt{STORE}.
        }

      \req{D\_EXM\_DATA\_OUTPUT\_01}{
          The value of the \texttt{result\_data\_o} shall be set to the value specified in table \ref{tab:exm-alu-output} considering the values of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}.
        }

      \begin{table}[H]
          \centering
          \input{arch/tables/10_exm-alu-output.tex}
          \caption{}
          \label{tab:exm-alu-output}
        \end{table}

      \req{D\_EXM\_BRANCH\_OUTPUT\_01}{
        The value of \texttt{branch\_o} shall be set to the value specified in table \ref{tab:exm-branch-output} considering the values of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}. 
        }

      \req{D\_EXM\_BRANCH\_OUTPUT\_02}{
          The \texttt{branch\_o} output shall be deasserted for any combinaison of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} which do not belong to table \ref{tab:exm-branch-output}.
        }

      \begin{content}
          The value of \texttt{result\_data\_o} is unspecified for any combinaison of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} which are not present in \ref{tab:exm-alu-output}.
        \end{content}

      \begin{table}[H]
          \centering
          \input{arch/tables/10_exm-branch-output.tex}
          \caption{}
          \label{tab:exm-branch-output}
        \end{table}

  \subsection{Behavior}

    \subsubsection{LUI behavior}

      \begin{content}
          The LUI behavior emits a register write request with the first input value. This value is the sign-extended immediate of the instruction, computed in the decode stage.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-lui.tex}
          \caption{Timing diagram of the LUI behavior of the execute module}
          \label{fig:exm-behavior-lui}
        \end{figure}

    \subsubsection{AUIPC behavior}

      \begin{content}
          The AUIPC behavior computes the sum of the first input with the program counter. This first input is the sign-extended immediate of the instruction, computed in the decode stage.
          
          A register write request is emitted to store the value.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-auipc.tex}
          \caption{Timing diagram of the AUIPC behavior of the execute module}
          \label{fig:exm-behavior-auipc}
        \end{figure}

    \subsubsection{Unconditional jump behavior}

      \paragraph{JAL}

      \begin{content}
          The JAL behavior emits a branch request to the address offset provided by the first input.
          
          A register write request is emitted to store the address of the following instruction.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-jump-jal.tex}
          \caption{Timing diagram of the jump behavior of the execute module for the JAL instruction}
          \label{fig:exm-behavior-jump-jal}
        \end{figure}

      \paragraph{JALR}

      \begin{content}
          The JALR behavior emits a branch request to the address offset provided by the sum of the first and second input.
          
          A register write request is emitted to store the address of the following instruction.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-jump-jalr.tex}
          \caption{Timing diagram of the jump behavior of the execute module for the JALR instruction}
          \label{fig:exm-behavior-jump-jalr}
        \end{figure}

    \subsubsection{Branch behavior}

      \begin{content}
          The branch behavior compares the first two inputs depending on the instruction variant. The BEQ and BNE variants check whether the two inputs are equal or not equal respectively. The BLT and BLTU variants check whether the first input is lower than the second input using a signed and unsigned comparison respectively. The BGE and BGEU variants check whether the first input is greater or equal to the second input using a signed and unsigned comparison respectively.
          
          A branch request is emitted in case of successful comparison, providing the address offset given in the third input.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-branch.tex}
          \caption{Timing diagram of the branch behavior of the execute module}
          \label{fig:exm-behavior-branch}
        \end{figure}

      \input{arch/tables/10_exm-behavior-branch}

    \subsubsection{Load behavior}

      \begin{content}
          The load behavior fetches an 8/16/32-bit word from memory at the address given in the first instruction input for the LB/LBU, LH/LHU and LW instructions respectively. The value is zero-extended to 32-bits for the U variants while it is signed extended to 32-bits otherwise. 
          
          A register write request is then emitted to store the value. 
          
          This behavior induces a pipeline stall due to the memory access time.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-load.tex}
          \caption{Timing diagram of the load behavior of the execute module}
          \label{fig:exm-behavior-load}
        \end{figure}

      \input{arch/tables/10_exm-behavior-load}

    \subsubsection{Store behavior}

      \begin{content}
          The store behavior writes a 8/16/32-bit word to memory at the address given in the first instruction input for the SB, SH and SW instructions respectively.

          Although there is no need for the pipeline to wait for the data to be written, this behavior induces a pipeline stall in revision 1.0.0 as a write request takes at least two cycles to complete while the memory interface shall be ready to receive new requests in the next pipeline cycle.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-store.tex}
          \caption{Timing diagram of the store behavior of the execute module}
          \label{fig:exm-behavior-store}
        \end{figure}

      \input{arch/tables/10_exm-behavior-store}

    \subsubsection{Arithmetic and logic behavior}

      \begin{content}
          The arithmetic and logic behavior applies to OP and OP-IMM opcodes. As DECM handles the processing of instruction inputs, both OP and OP-IMM instructions have the same associated behavior in EXM.

          The arithmetic and logic behavior computes the following integer operations : signed sum, signed substraction, bitwise exclusive-or, bitwise or, bitwise and, signed comparison, unsigned comparison, left logical shift, right logical shift and right arithmetic shift.
          
          A register write request is then emitted to store the value.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-arithmetic-logic.tex}
          \caption{Timing diagram of the arithmetic and logic behavior of the execute module}
          \label{fig:exm-behavior-arithmetic-logic}
        \end{figure}

      \input{arch/tables/10_exm-behavior-arithmetic-logic}

    \subsubsection{Hazard behaviors}

      \begin{content}
          Hazard behaviors are described in section \ref{pipeline-stall}.
        \end{content}

\newpage

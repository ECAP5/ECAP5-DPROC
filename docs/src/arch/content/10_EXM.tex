\section{Execute Module}

  \subsection{Interface}

    \begin{content}
        The execute module implements TBC. The signals are described in table \ref{tab:exm-interface}. 
      \end{content}

    \input{arch/tables/10_exm-interface}

  \subsection{Specification}

    \subsubsection{State machine}
       
    \subsubsection{Input registering}

      \event{EV\_EXM\_INPUT\_REGISTER\_01}{
          This event represents a successfull input handshake.
        }

      \req{D\_EXM\_INPUT\_REGISTER\_01}{
          On the rising edge of \texttt{clk\_i} when both \texttt{input\_valid\_i} and \texttt{input\_ready\_o} are asserted, \eventref{EV\_EXM\_INPUT\_REGISTER\_01} shall be triggered.
        }

    \subsubsection{Load/Store}
      
      \req{D\_EXM\_LOAD\_TRIGGER\_01}{
          A one byte wishbone read cycle shall be triggered on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is \texttt{LOAD} and \texttt{func3\_i} is either \texttt{LB-FUNC3} or \texttt{LBU-FUNC3}.
        }

      \req{D\_EXM\_LOAD\_TRIGGER\_01}{
          A two byte wishbone read cycle shall be triggered on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is \texttt{LOAD} and \texttt{func3\_i} is either \texttt{LH-FUNC3} or \texttt{LHU-FUNC3}.
        }

      \req{D\_EXM\_LOAD\_TRIGGER\_01}{
          A four byte wishbone read cycle shall be triggered on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is \texttt{LOAD} and \texttt{func3\_i} is \texttt{LW-FUNC3}.
        }

    \subsubsection{Wishbone interface}

      \begin{content}
          The following requirements are extracted from the Wishbone specification for implementing the memory interface of the execute module.
        \end{content}

      \req{D\_EXM\_WISHBONE\_DATASHEET\_01}{
          The memory interface shall comply with the Wishbone Datasheet provided in section \ref{user-needs}.
        }

      \req{D\_EXM\_WISHBONE\_RESET\_01}{
          The memory interface shall initialize itself at the rising edge of \texttt{clk\_i} following the assertion of \texttt{rst\_i}.
        }

      \req{D\_EXM\_WISHBONE\_RESET\_02}{
          The memory interface shall stay in the initialization state until the rising edge of \texttt{clk\_i} following the deassertion of \texttt{rst\_i}.
        }

      \req{D\_EXM\_WISHBONE\_RESET\_03}{
          Signals \texttt{wb\_stb\_o} and \texttt{wb\_cyc\_o} shall be deasserted while the memory interface is in the initialization state. The state of all other memory interface signals are undefined in response to a reset cycle.
        }

      \req{D\_EXM\_WISHBONE\_TRANSFER\_CYCLE\_01}{
          The memory interface shall assert \texttt{wb\_cyc\_o} for the entire duration of the memory access.
        }[
          rationale=TBC what wb\_cyc\_o does.
        ]

      \req{D\_EXM\_WISHBONE\_TRANSFER\_CYCLE\_02}{
          Signal \texttt{wb\_cyc\_o} shall be asserted no later than the rising edge of \texttt{clk\_i} that qualifies the assertion of \texttt{wb\_stb\_o}.
        }

      \req{D\_EXM\_WISHBONE\_TRANSFER\_CYCLE\_03}{
            Signal \texttt{wb\_cyc\_o} shall be deasserted no earlier than the rising edge of \texttt{clk\_i} that qualifies the deassertion of \texttt{wb\_stb\_o}.
        }

      \req{D\_EXM\_WISHBONE\_HANDSHAKE\_01}{
          The memory interface shall accept \texttt{wb\_ack\_i} signals at any time after a transaction is initiated.
        }

      \req{D\_EXM\_WISHBONE\_HANDSHAKE\_02}{
          The memory interface must qualify the following signals with \texttt{wb\_stb\_o} : \texttt{wb\_adr\_o}, \texttt{wb\_dat\_o}, \texttt{wb\_sel\_o} and \texttt{wb\_we\_o}.
        }

      \req{D\_EXM\_WISHBONE\_STALL\_01}{
          While initiating a request, the memory interface shall hold the state of its outputs until \texttt{wb\_stall\_i} is deasserted.
        }

      \vspace{0.5em}

      \begin{figure}[H]
          \centering
          \input{arch/figures/3_wishbone-single-read-cycle}
          \caption{Timing diagram of the single read cycle of the wishbone memory interface}
          \label{fig:exm-wishbone-single-read-cycle}
        \end{figure}

      \input{arch/tables/10_exm-wishbone-single-read-cycle}

      \req{D\_EXM\_WISHBONE\_READ\_CYCLE\_01}{
          A read transaction shall be started by asserting both \texttt{wb\_cyc\_o} and \texttt{wb\_stb\_o}, and deasserting \texttt{wb\_we\_o}.
        }

      \req{D\_EXM\_WISHBONE\_READ\_CYCLE\_02}{
          The memory interface shall conform to the READ cycle detailed in figure \ref{fig:exm-wishbone-single-read-cycle}.
        }

      \vspace{0.5em}

        \begin{figure}[H]
            \centering
            \input{arch/figures/3_wishbone-single-write-cycle}
            \caption{Timing diagram of the single write cycle of the wishbone memory interface}
            \label{fig:exm-wishbone-single-write-cycle}
          \end{figure}

        \input{arch/tables/10_exm-wishbone-single-write-cycle}

        \req{D\_EXM\_WISHBONE\_WRITE\_CYCLE\_01}{
            A write transaction shall be started by asserting \texttt{wb\_cyc\_o}, \texttt{wb\_stb\_i} and \texttt{wb\_we\_o}.
          }[
            derivedfrom=U\_MEMORY\_INTERFACE\_02
          ]

        \req{D\_EXM\_WISHBONE\_WRITE\_CYCLE\_02}{
            The memory interface shall conform to the WRITE cycle detailed in figure \ref{fig:exm-wishbone-single-write-cycle}.
          }[
            derivedfrom=U\_MEMORY\_INTERFACE\_02
          ]

      \req{D\_EXM\_WISHBONE\_TIMING\_01}{
          The clock input \texttt{clk\_i} shall coordinate all activites for the internal logic within the memory interface. All output signals of the memory interface shall be registered at the rising edge of \texttt{clk\_i}. All input signals of the memory interface shall be stable before the rising edge of \texttt{clk\_i}.
        }[
          rationale={As long as the memory interface is designed within the clock domain of \texttt{clk\_i}, the requirement will be satisfied by using the place and route tool.}
        ]

    \subsubsection{Output}

      \req{D\_EXM\_OUTPUT\_ADDR\_01}{
          The value of \texttt{result\_addr\_o} shall be set the to the value of \texttt{result\_addr\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}.
        }

      \req{D\_EXM\_OUTPUT\_WRITE\_01}{
          The \texttt{result\_write\_o} output shall be asserted on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is one of the following : \texttt{LUI}, \texttt{AUIPC}, \texttt{JAL}, \texttt{JALR}, \texttt{OP} and \texttt{OP-IMM}.
        }

      \req{D\_EXM\_OUTPUT\_WRITE\_02}{
          The value of \texttt{result\_write\_o} shall be deasserted on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01} when \texttt{opcode\_i} is \texttt{BRANCH}.
        }

      \req{D\_EXM\_OUTPUT\_WRITE\_03}{
          The value of \texttt{result\_write\_o} shall be asserted on the rising edge of \texttt{clk\_i} following the completion of the memory request when \texttt{opcode\_i} is one of the following: \texttt{LOAD} and \texttt{STORE}.
        }

      \req{D\_EXM\_OUTPUT\_DATA\_01}{
          The value of the \texttt{result\_data\_o} shall be set to the value specified in table \ref{tab:exm-alu-output} considering the values of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}.
        }

      \begin{table}[H]
          \centering
          \input{arch/tables/10_exm-alu-output.tex}
          \caption{}
          \label{tab:exm-alu-output}
        \end{table}

      \begin{content}
          The value of \texttt{result\_data\_o} is unspecified for any combinaison of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} which are not present in \ref{tab:exm-alu-output}.
        \end{content}

      \req{D\_EXM\_OUTPUT\_BRANCH\_01}{
        The value of \texttt{branch\_o} shall be set to the value specified in table \ref{tab:exm-branch-output} considering the values of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}. 
        }

      \req{D\_EXM\_OUTPUT\_BRANCH\_02}{
          The \texttt{branch\_o} output shall be deasserted for any combinaison of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} which do not belong to table \ref{tab:exm-branch-output}.
        }

      \begin{table}[H]
          \centering
          \input{arch/tables/10_exm-branch-output.tex}
          \caption{}
          \label{tab:exm-branch-output}
        \end{table}

      \req{D\_EXM\_OUTPUT\_BOFFSET\_01}{
          The value of \texttt{boffset\_o} shall be set to the value specified in table \ref{tab:exm-boffset-output} considering the values of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} on the rising edge of \texttt{clk\_i} following the triggering of \eventref{EV\_EXM\_INPUT\_REGISTER\_01}. 
        }

      \begin{table}[H]
          \centering
          \input{arch/tables/10_exm-boffset-output.tex}
          \caption{}
          \label{tab:exm-boffset-output}
        \end{table}

      \begin{content}
          The value of \texttt{boffset\_o} is unspecified for any combinaison of \texttt{opcode\_i}, \texttt{func3\_i} and \texttt{func7\_i} which are not present in \ref{tab:exm-boffset-output}.
        \end{content}

    \subsubsection{Output handshake}

  \subsection{Behavior}

    \subsubsection{LUI behavior}

      \begin{content}
          The LUI behavior emits a register write request with the first input value. This value is the sign-extended immediate of the instruction, computed in the decode stage.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-lui.tex}
          \caption{Timing diagram of the LUI behavior of the execute module}
          \label{fig:exm-behavior-lui}
        \end{figure}

    \subsubsection{AUIPC behavior}

      \begin{content}
          The AUIPC behavior computes the sum of the first input with the program counter. This first input is the sign-extended immediate of the instruction, computed in the decode stage.
          
          A register write request is emitted to store the value.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-auipc.tex}
          \caption{Timing diagram of the AUIPC behavior of the execute module}
          \label{fig:exm-behavior-auipc}
        \end{figure}

    \subsubsection{Unconditional jump behavior}

      \paragraph{JAL}

      \begin{content}
          The JAL behavior emits a branch request to the address offset provided by the first input.
          
          A register write request is emitted to store the address of the following instruction.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-jump-jal.tex}
          \caption{Timing diagram of the jump behavior of the execute module for the JAL instruction}
          \label{fig:exm-behavior-jump-jal}
        \end{figure}

      \paragraph{JALR}

      \begin{content}
          The JALR behavior emits a branch request to the address offset provided by the sum of the first and second input.
          
          A register write request is emitted to store the address of the following instruction.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-jump-jalr.tex}
          \caption{Timing diagram of the jump behavior of the execute module for the JALR instruction}
          \label{fig:exm-behavior-jump-jalr}
        \end{figure}

    \subsubsection{Branch behavior}

      \begin{content}
          The branch behavior compares the first two inputs depending on the instruction variant. The BEQ and BNE variants check whether the two inputs are equal or not equal respectively. The BLT and BLTU variants check whether the first input is lower than the second input using a signed and unsigned comparison respectively. The BGE and BGEU variants check whether the first input is greater or equal to the second input using a signed and unsigned comparison respectively.
          
          A branch request is emitted in case of successful comparison, providing the address offset given in the third input.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-branch.tex}
          \caption{Timing diagram of the branch behavior of the execute module}
          \label{fig:exm-behavior-branch}
        \end{figure}

      \input{arch/tables/10_exm-behavior-branch}

    \subsubsection{Load behavior}

      \begin{content}
          The load behavior fetches an 8/16/32-bit word from memory at the address given in the first instruction input for the LB/LBU, LH/LHU and LW instructions respectively. The value is zero-extended to 32-bits for the U variants while it is signed extended to 32-bits otherwise. 
          
          A register write request is then emitted to store the value. 
          
          This behavior induces a pipeline stall due to the memory access time.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-load.tex}
          \caption{Timing diagram of the load behavior of the execute module}
          \label{fig:exm-behavior-load}
        \end{figure}

      \input{arch/tables/10_exm-behavior-load}

    \subsubsection{Store behavior}

      \begin{content}
          The store behavior writes a 8/16/32-bit word to memory at the address given in the first instruction input for the SB, SH and SW instructions respectively.

          Although there is no need for the pipeline to wait for the data to be written, this behavior induces a pipeline stall in revision 1.0.0 as a write request takes at least two cycles to complete while the memory interface shall be ready to receive new requests in the next pipeline cycle.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-store.tex}
          \caption{Timing diagram of the store behavior of the execute module}
          \label{fig:exm-behavior-store}
        \end{figure}

      \input{arch/tables/10_exm-behavior-store}

    \subsubsection{Arithmetic and logic behavior}

      \begin{content}
          The arithmetic and logic behavior applies to OP and OP-IMM opcodes. As DECM handles the processing of instruction inputs, both OP and OP-IMM instructions have the same associated behavior in EXM.

          The arithmetic and logic behavior computes the following integer operations : signed sum, signed substraction, bitwise exclusive-or, bitwise or, bitwise and, signed comparison, unsigned comparison, left logical shift, right logical shift and right arithmetic shift.
          
          A register write request is then emitted to store the value.
        \end{content}

      \begin{figure}[H]
          \centering
          \input{arch/figures/10_exm-behavior-arithmetic-logic.tex}
          \caption{Timing diagram of the arithmetic and logic behavior of the execute module}
          \label{fig:exm-behavior-arithmetic-logic}
        \end{figure}

      \input{arch/tables/10_exm-behavior-arithmetic-logic}

    \subsubsection{Hazard behaviors}

      \begin{content}
          Hazard behaviors are described in section \ref{pipeline-stall}.
        \end{content}

\newpage

\section{Instruction Fetch Module}

\begin{figure}[h!]
    \centering
    \input{arch/figures/ifm-arch}
    \caption{Schematic view of the Instruction Fetch Module}
    \label{fig:ifm}
\end{figure}

\subsection{Interface}

\begin{content}
The instruction fetch module handles fetching from memory the instructions to be executing. The signals are described in table \ref{tab:ifm-interface}. 
\end{content}

\input{arch/tables/ifm-interface}

\subsection{Specification}

\subsubsection{Upstream requirements}

The table \ref{tab:ifm-upstream-requirements} outlines the upstream requirements applicable to the Instruction Fetch Module.

\input{arch/tables/ifm-upstream-requirements}

\subsubsection{Functional requirements}

\paragraph{PC register}

\req{D\_IFM\_PC\_REGISTER\_01}{
  The instruction fetch module shall implement a \texttt{pc} register which shall store the address of the instruction to be fetched.
}[
  derivedfrom=F\_REGISTERS\_03
]

\req{D\_IFM\_PC\_INCREMENT\_01}{
  The value of the \texttt{pc} register shall be incremented by 4 on the rising edge of \texttt{clk\_i} after both \texttt{output\_ready\_i} and \texttt{output\_valid\_o} where asserted.
}

\req{D\_IFM\_PC\_INCREMENT\_02}{
  The value of the \texttt{pc} register shall be incremented by the value of the \texttt{boffset\_i} on the rising edge of \texttt{clk\_i} when \texttt{branch\_i} is asserted.
}


\req{D\_IFM\_PC\_LOAD\_01}{
  The value of the \texttt{pc} register shall be loaded with TBC on the rising edge of \texttt{clk\_i} when \texttt{irq\_i} is asserted.
}

\req{D\_IFM\_PC\_LOAD\_02}{
  The value of the \texttt{pc} register shall be loaded with TBC on the rising edge of \texttt{clk\_i} when \texttt{drq\_i} is asserted.
}

\req{D\_IFM\_PC\_REGISTER\_02}{
  Any changes to the \texttt{pc} register shall be performed before any memory requests.
}

\paragraph{Reset}

\req{D\_IFM\_RESET\_01}{
  The value of the \texttt{pc} register shall be loaded with TBC on the rising edge of \texttt{clk\_i} following the assertion of \texttt{rst\_i}.
}

\req{D\_IFM\_RESET\_02}{
  The \texttt{output\_valid\_o} signal shall be deasserted on the rising edge of \texttt{clk\_i} following the assertion of \texttt{rst\_i}.
}

\paragraph{Fetch triggering}

\req{D\_IFM\_FETCH\_TRIGGER\_01}{
  The instruction fetch module shall perform a memory request on the rising edge of \texttt{clk\_i} following the deassertion of \texttt{rst\_i}.
}

\req{D\_IFM\_FETCH\_TRIGGER\_02}{
  The instruction fetch module shall perform a memory request on the rising edge of \texttt{clk\_i} after both \texttt{output\_ready\_i} and \texttt{output\_valid\_o} are asserted.
}

\paragraph{Memory request}

\req{D\_IFM\_REQUEST\_CANCEL\_01}{
  Any pending memory requests shall be canceled on the rising edge of \texttt{clk\_i} following the assertion of \texttt{rst\_i}.
}

\req{D\_IFM\_REQUEST\_CANCEL\_02}{
  Any pending memory requests shall be canceled on the rising edge of \texttt{clk\_i} following the assertion of \texttt{irq\_i}.
}

\req{D\_IFM\_REQUEST\_CANCEL\_03}{
  Any pending memory requests shall be canceled on the rising edge of \texttt{clk\_i} following the assertion of \texttt{drq\_i}.
}

\req{D\_IFM\_REQUEST\_CANCEL\_04}{
  Any pending memory requests shall be canceled on the rising edge of \texttt{clk\_i} following the assertion of \texttt{branch\_i}.
}

\begin{content}
    The following requirements are extracted from the Wishbone specification for implementing the memory interface of the instruction fetch module.
\end{content}

\req{D\_IFM\_WISHBONE\_DATASHEET\_01}{
  The memory interface shall comply with the Wishbone Datasheet provided in section TBC.
}


\req{D\_IFM\_WISHBONE\_RESET\_01}{
  The memory interface shall initialize itself at the rising edge of \texttt{clk\_i} following the assertion of \texttt{rst\_i}.
}


\req{D\_IFM\_WISHBONE\_RESET\_02}{
  The memory interface shall stay in the initialization state until the rising edge of \texttt{clk\_i} following the deassertion of \texttt{rst\_i}.
}


\req{D\_IFM\_WISHBONE\_RESET\_03}{
  Signals \texttt{wb\_stb\_o} and \texttt{wb\_cyc\_o} shall be deasserted while the memory interface is in the initialization state. The state of all other memory interface signals are undefined in response to a reset cycle.
}[
]

\req{D\_IFM\_WISHBONE\_TRANSFER\_CYCLE\_01}{
  The memory interface shall assert \texttt{wb\_cyc\_o} for the entire duration of the memory access.
}[
  rationale=TBC what wb\_cyc\_o does.
]

\req{D\_IFM\_WISHBONE\_TRANSFER\_CYCLE\_02}{
  Signal \texttt{wb\_cyc\_o} shall be asserted no later than the rising edge of \texttt{clk\_i} that qualifies the assertion of \texttt{wb\_stb\_o}.
}[
]

\req{D\_IFM\_WISHBONE\_TRANSFER\_CYCLE\_03}{
  Signal \texttt{wb\_cyc\_o} shall be deasserted no earlier than the rising edge of \texttt{clk\_i} that qualifies the deassertion of \texttt{wb\_stb\_o}.
}[
]

\req{D\_IFM\_WISHBONE\_ACK\_01}{
  The memory interface shall operate normally when \texttt{ack\_i} is held in the asserted state.
}[
]

\req{D\_IFM\_WISHBONE\_STB\_01}{
  The following signals shall be valid when \texttt{stb\_o} is asserted : \texttt{adr\_o}, \texttt{sel\_o}.
}[
]

\req{D\_IFM\_WISHBONE\_CYCLES\_01}{
  The memory interface shall implement the single read cycle as described in figure \ref{fig:ifm-wishbone-single-read-cycle}.
}[
]

\vspace{0.5em}

\begin{figure}[h!]
    \centering
    \input{arch/figures/ifm-wishbone-single-read-cycle}
    \caption{Timing diagram of the single read cycle of the wishbone memory interface}
    \label{fig:ifm-wishbone-single-read-cycle}
\end{figure}

\input{arch/tables/ifm-wishbone-single-read-cycle}

\req{D\_IFM\_WISHBONE\_TIMING\_01}{
  The clock input \texttt{clk\_i} shall coordinate all activites for the internal logic within the memory interface. All output signals of the memory interface shall be registered at the rising edge of \texttt{clk\_i}. All input signals of the memory interface shall be stable before the rising edge of \texttt{clk\_i}.
}[
  rationale={As long as the memory interface is designed within the clock domain of \texttt{clk\_i}, the requirement will be satisfied by using the place and route tool.}
]

\paragraph{Output}

\req{D\_IFM\_OUTPUT\_01}{
  The signal \texttt{instr\_o} shall be set to the result of the memory request on the rising edge of \texttt{clk\_i} when the memory request is completed.
}

\req{D\_IFM\_OUTPUT\_02}{
  The signal \texttt{pc\_o} shall be set asynchronously to the value of the \texttt{pc} register.
}

\req{D\_IFM\_OUTPUT\_HANDSHAKE\_01}{
  The signal \texttt{output\_valid\_o} shall be deasserted on the rising edge of \texttt{clk\_i} when the instruction fetch module performs an instruction fetch.
}[
  rationale=Refer to section \ref{control-hazard}.
]

\req{D\_IFM\_OUTPUT\_HANDSHAKE\_02}{
  The signal \texttt{output\_valid\_o} shall be asserted on the rising edge of \texttt{clk\_i} when the instruction fetch is completed.
}[
  rationale=Refer to section \ref{control-hazard}.
]

\req{D\_IFM\_OUTPUT\_HANDSHAKE\_03}{
  When \texttt{output\_valid\_o} is asserted, the instruction fetch module shall hold the value of the \texttt{instr\_o} signal until the rising edge of \texttt{clk\_i} following the assertion of \texttt{output\_ready\_i}.
}[
  rationale=Refer to section \ref{pipeline-stall}.
]

\req{D\_IFM\_OUTPUT\_HANDSHAKE\_04}{
  When \texttt{output\_valid\_o} is asserted, the instruction fetch module shall hold the value of the \texttt{pc\_o} signal until the rising edge of \texttt{clk\_i} following the assertion of \texttt{output\_ready\_i}.
}[
  rationale=Refer to section \ref{pipeline-stall}.
]


\subsection{Behavior}

\begin{content}
  This module doesn't contain any prefetch mechanism as there is no performance requirement for version 1.0.0. This will lead to a performance bottleneck due to the number of cycles needed for fetching instructions from memory.
\end{content}

\subsubsection{Normal behavior}

\begin{content}
  During normal operation, the instruction fetch module sequentially emits memory requests to address stored in the \texttt{pc} register. Upon successful request, \texttt{pc} is incremented to point to the following instruction.

  This behavior induces a pipeline stall due to the delay of the wishbone interface.
\end{content}

\begin{figure}[H]
    \centering
    \input{arch/figures/ifm-behavior-normal.tex}
    \caption{Timing diagram of the normal behavior of the instruction fetch module}
    \label{fig:ifm-behavior-normal}
\end{figure}

\subsubsection{Reset behavior}

\begin{content}
  Once a reset occurs, \texttt{pc} is loaded with the boot address before returning to normal operation.

  This behavior doesn't induce any pipeline stall \textit{per se} as the pipeline is reset during this operation.
\end{content}

\begin{figure}[H]
    \centering
    \input{arch/figures/ifm-behavior-reset.tex}
    \caption{Timing diagram of the reset behavior of the instruction fetch module}
    \label{fig:ifm-behavior-reset}
\end{figure}

\subsubsection{Resource busy behavior}

\begin{content}
  The instruction fetch module is capable of handling wait states from memory through the stalling mechanism.
\end{content}

\begin{figure}[H]
    \centering
    \input{arch/figures/ifm-behavior-wait.tex}
    \caption{Timing diagram of the memory resource busy behavior of the instruction fetch module}
    \label{fig:ifm-behavior-wait}
\end{figure}

\subsubsection{Jump behavior}

\begin{content}
  TBC
\end{content}

\begin{figure}[H]
    \centering
    \input{arch/figures/ifm-behavior-jump-branch.tex}
    \caption{Timing diagram of the jump behavior of the instruction fetch module for branch events}
    \label{fig:ifm-behavior-branch}
\end{figure}

\begin{figure}[H]
    \centering
    \input{arch/figures/ifm-behavior-jump-interrupt.tex}
    \caption{Timing diagram of the jump behavior of the instruction fetch module for interrupt events}
    \label{fig:ifm-behavior-interrupt}
\end{figure}

\subsubsection{Hazard behaviors}

\begin{content}
  Hazard behaviors are described in section \ref{pipeline-stall}.
\end{content}

\newpage
